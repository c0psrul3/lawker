#!/bin/gawk -f
# fsm.awk
# $Revision: 1.5 $
#   NB: requires gawk version 3.1.2 or greater
# 
# ======================================================================
# Copyright 2008 Wm Miller
# 
# This file is part of fsm-gen, and is distributed under the terms of the
# GNU Lesser General Public License .
# 
# Copies of the GNU General Public License and the GNU Lesser General Public
# License are included with this distrubution in the files COPYING and
# COPYING.LESSER, respectively.
# 
# Fsm-gen is free software: you can redistribute it and/or modify it under the
# terms of the GNU Lesser General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
# 
# Fsm-gen is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
# more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with fsm-gen.  If not, see <http://www.gnu.org/licenses/>.
# 
# The author may be contacted at wmmsf at users.sourceforge.net.
# ======================================================================
#
BEGIN {
    weWannaExit = 0
    #printf "argc is %d \n\n", ARGC
    if (ARGC < 2) {
        print "usage: fsm.awk fsm_definition_filename" > "/dev/stderr"
        print "  for example, fsm.awk test.fsm"
        weWannaExit = 1
    }

    
    filename = ARGV[1]
    FSMNAME = substr(filename, 1, index(filename, ".") - 1)
    #print "reading file " filename
    #print "FSMNAME is " FSMNAME

    # see if the file exists
    # this causes the first line of the file to be eaten and
    # swallowed, and close doesn't fix it.
    getline
    close(FILENAME)

    coutfile = "fsm_" FSMNAME ".c"
    houtfile = "fsm_" FSMNAME ".h"

    #weWannaExit = 1
    if (weWannaExit) {exit}
# ****************************************************************
# output che top constant part of fsm_xxx.c
    cfileHeader =  \
"// fsm_test.c \n\
// $Revision: 1.5 $ \n\
\n\
// NB: don't edit this file - it was generated by fsm.awk and will \n\
//  be overwritten when the files are re-generated. \n\
//\n\
// uncomment this if/when we get time to support it \n\
//#include <err.h> \n\
\n\
#include \"utils.h\" \n\
#include \"fsm.h\" \n\
#include \"fsm_test.h\" \n\n"

    printf "%s\n", cfileHeader > coutfile 

 
# ****************************************************************
# ****************************************************************
# output the top constant part of fsm_xxx.h

    printf "\
// fsm_%s.h \n\
// $Revision: 1.5 $ \n\
\n\
// NB: don't edit this file - it was generated by fsm.awk and will \n\
//  be overwritten when the files are re-generated. \n\
// \n\
\n\
#ifndef _FSM_%s_H \n\
#define _FSM_%s_H \n\
\n\
\n", FSMNAME, toupper(FSMNAME), toupper(FSMNAME)  > houtfile

    # note that if :blank: is used here, it can't be used in
    # regexp below - if so, must use [<space><tab>] in the body 
    #FS = "[:blank:]"

    // init array indices
    stateIndex = 0
    eventIndex = 0
    actionIndex = 0
    }
# =====================================================================
    # BODY
    #
function recordTransition(state, event, action, okState, failState)
{
    #print "recording..." state " " event " " action " " okState " " failState
    #printf "state is %s -- ", state
    #printf "event is %s \n", event

    #if (comma in events, break events up and recurs here)
    if (index(event, ",")) {
        n = split(event, evt, ",")
#print "+++++++++++++++++++++++++++++++++++++++++++"
        for (n; n; --n) {
#print "recursing (" n ")..."
            recordTransition(state, evt[n], action, okState, failState)
            }
#print "+++++++++++++++++++++++++++++++++++++++++++"
        return
    }

    if (state in statenames) dummy = 1 #print "state in there"
    else {
        statenames[state] = stateIndex;
        states[stateIndex] = state
        stateIndex++
    }

    if (event in eventnames) dummy = 1 #print "event in there"
    else {
        eventnames[event] = eventIndex; events[eventIndex] = event
        events[eventIndex] = event
        eventIndex++
    }


    # record a list of action function names
    # use name in index of actionnames so we can use
    # "if action in actionlist" construct to weed out dups
    if (action != "" && action != "NULL") {
        if (action in actionnames) dummy = 1 #print "action in there"
        else {
            actionnames[action] = actionIndex; actions[actionIndex] = action
            actionlist[actionIndex] = action
            actionIndex++
        }
    }

    actions[state, event] = action
    nextstate[state, event, "ok"] = okState
    nextstate[state, event, "fail"] = failState
}

function printStates()
{
    print "\n"
    print "---------------"
    for (i = 1; i <= numberOfStates; i++) {
        printf "// states.%d = %s \n", i, sortedstates[i]
    }
}

function printEvents()
{
    print "\n"
    print "---------------"
    for (i = 1; i <= numberOfEvents; i++) {
        printf "// events.%d = %s \n", i, sortedevents[i]
    }
}

# actions is not sorted, thus "act in actions" instead of 
#   incrementing index
function printActions()
{
    print "\n"
    print "---------------"
    print "actions"
    for (act in actions) {
        printf "actions.%s is %s \n", act, actions[act]
    }
}

# trans(itions) is not sorted, thus "act in actions" instead of 
#   incrementing index
function printTrans()
{
    print "\n"
    print "---------------"
    print "trans"
    for (tr in trans) {
        printf "trans.%s is %s \n", tr, trans[tr]
    }
}


    # step 1:  scan the input file and build (possibly sparse)
    #   arrays of states and events
    # ignore comments
    /^[ 	]*#/ {next}
    
    # ignore blank lines
    /^$|^[ 	]*$/  {next}

    # transition lines with state specified
    /^[[:alnum:]_]+[ 	]/ {
        STATE = $1; # printf "state is %s -- ", STATE
        recordTransition(STATE, $2,
                         $3 && $3 != "-"  ? $3 : "NULL",
                         $4 && $4 != "-" ? $4 : STATE,
                         $5 && $5 != "-" ? $5 : STATE)
        next
    }


    # transition lines with state unspecified
    /^[ 	]+/ {
        recordTransition(STATE, $1,
                         $2 && $2 != "-"  ? $2 : "NULL",
                         $3 && $3 != "-"  ? $3 : STATE,
                         $4 && $4 != "-"  ? $4 : STATE)
        next
    }


    END {
        if (weWannaExit) {exit}


        # step 2: fill in any unspecified transitions
        #   note that unspecified transitions means events are not
        #   valid for that state
        #if event is ANY, fill in the details


        numberOfStates = asort(states, sortedstates)
        numberOfEvents = asort(events, sortedevents)

        print "#define STATES_COUNT " numberOfStates > houtfile
        print "#define EVENTS_COUNT " numberOfEvents > houtfile
        
        #print enum for states()   
        print "enum states {"   > houtfile
        for (s = 1; s <= numberOfStates; ++s) {
            print "    " sortedstates[s] ((s < numberOfStates) ? "," : " ")   > houtfile
        }
        print "};"  > houtfile
        print ""    > houtfile

        
        #print enum for events()
        print "enum events {"   > houtfile
        for (e=1; e <= numberOfEvents; ++e)  {
            print "    " sortedevents[e]   ((e < numberOfEvents) ? "," : " ")   > houtfile
        }
        print "};"  > houtfile
        print ""    > houtfile

        # declaration for the transition table
        print "extern struct fsm_s fsm_" FSMNAME "[" numberOfStates "][" numberOfEvents "];"     > houtfile
        print ""    > houtfile
        

        # declaration for action functions
        for (act in actionlist) {
                print "extern bool " actionlist[act] "(void);"     > houtfile
        }
        print ""    > houtfile

        #print "extern unsigned int fsmContext_" FSMNAME ";"    > houtfile
        print ""    > houtfile

        print "// call this fcn once at startup"    > houtfile
        print "extern unsigned int fsm_" FSMNAME "_init(void);"     > houtfile
        print ""    > houtfile
        print "#endif /* _FSM_" toupper(FSMNAME) "_H */"    > houtfile




        print "\n"  > coutfile
        #print "---------------"     > coutfile
        #print "the table: \n"
        #print "{"
print "// transition data for the " FSMNAME " fsm"  > coutfile
print "struct fsm_s  fsm_" FSMNAME " [STATES_COUNT][EVENTS_COUNT] = {"  > coutfile
        for (s = 1; s <= numberOfStates; ++s) {
            print "  { // state = " sortedstates[s] " (" s-1 ")"     > coutfile
            for (e=1; e <= numberOfEvents; ++e) {
                printf "    { "     > coutfile
                #####_s = states[sortedstates[s]]
                ####_e = events[sortedevents[e]]
                _s = sortedstates[s]
                _e = sortedevents[e]

                _a = actions[_s,_e] ? actions[_s,_e] : "NULL"
                _nsok = nextstate[_s, _e, "ok"] ? nextstate[_s, _e, "ok"] : _s
                _nsfail = nextstate[_s, _e, "fail"] ? nextstate[_s, _e, "fail"] : _s

                printf "%s, %s, %s", _a, _nsok, _nsfail     > coutfile

                printf " }%s",
                    ((e < numberOfEvents) || (s < numberOfStates)) ? "," : " "  > coutfile
                print "        // event = " sortedevents[e] " (" e-1 ")"   > coutfile
                #print "    " _e " : " _s   > coutfile
                }
            printf "  }%s \n", ((s < numberOfStates)) ? "," : " "   > coutfile
            }
        print "};"  > coutfile
        print ""    > coutfile


        close(coutfile)
        close(houtfile)

print "numberOfEvents is " numberOfEvents
print "numberOfStates is " numberOfStates
print "output files are " coutfile " and " houtfile


    }


