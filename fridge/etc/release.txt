????
stop gaps:
	- editorial: awkwords?
	- stuff from sed & awk
	- more functional stuff
	- saya
	- batchrunner

5555555555555555555
- awk100:   ronold lou's soccer game
- fun: eliza.awk

- new section on postscript manipulation tools
	- robbin's postscript tools

- bash formatter
      http://mail.google.com/mail/#label/awk.info/1201bb25d80abedd

66666666666666666
- awk100: the amazing awk assembler
- new section on awk interpreters 
	awk assembler, 
	awklisp
	aasl
	awkastar
- quick sort in awk
- fun: sig generator
    rot13 :http://www.rosettacode.org/wiki/Rot-13#AWK

in praise of scripting

visual awk

aaa77777777777777777777
- akw100 oo in ansi "C" awk packages. axel schreiner
- new section on operating ssytems and awk (awk linux) and 
	http://www.icir.org/tfrc/sims1.html
	share/pdf/awkalert.pdf
	http://www.icir.org/tfrc/sims1.htmlP
	awk-linux


append data to fields, not records
http://groups.google.com/group/comp.lang.awk/browse_thread/thread/38ae5bede3673abf/53966eded19904ca#53966eded19904ca

-tips: getting shell variables into awk. 
	- config file	
	- double quotes
	- the '$' trick


888888888888888888
awk100: xgawk
- new section of xml processing and gawk
	- xgawk
    - xmlgawk.awk

xml processing with awk
http://home.vrweb.de/~juergen.kahrs/gawk/XML/xmlgawk.html#Reading-XML-Data-with-POSIX-AWK
display awk:
http://groups.google.com/group/comp.lang.awk/browse_thread/thread/1311a8b04a802265/f5a7d1d714297f00?lnk=gst&q=xml#f5a7d1d714297f00
xml file using shell script
http://www.issociate.de/board/post/265610/Parse_an_XML_File_using_Shell_script.html

code testing: kernighan
spread sheet access: http://www.freakout.de/mc.htm#Piping

reading tabular data
awktemplate
Template-driven interfaces for numerical subroutines
Full text       PdfPdf (1.28 MB)
Source  ACM Transactions on Mathematical Software (TOMS) archive
Volume 19 ,  Issue 3  (September 1993) table of contents
Pages: 265 - 287
Year of Publication: 1993
ISSN:0098-3500

fun: my bayes stuff

9999999999999999
awk100: jawk
new section: more xml with gawk
- http://chiranth.blogspot.com/2007/02/using-awk-to-parse-html.html

steve coile's xgawk
http://groups.google.com/group/comp.lang.awk/msg/8f094ce6f0a32492?&q=xml
karhs getmxl vs xgawk:
http://groups.google.com/group/comp.lang.awk/browse_thread/thread/af74e60cb72e119c/38710ddc81e0bbc2?lnk=gst&q=xml#38710ddc81e0bbc2

correlations in gawk
http://www.cs.ucsb.edu/~sherwood/awk/corrcoef.awk.txt

pdf/awkverify.awk

000000000000000000
new section on scientific computation and awk:
eiso's awk scrits- if i understood what they did
mechanical engineering ask scripts: http://www.tikmark.com/awkeng/awkscripts.htmldomain specific langauges

awk100: fsa generator
http://www.stumbleupon.com/redirect.php?t=i&u=13309825&d=http%3A%2F%2Fsourceforge.net%2Fproject%2Fplatformdownload.php%3Fgroup_id%3D242703&l=2&c=baj1senra2q0xfqs
uml generator
http://www.theficks.name/bin/lib/sdml/sdml2txt

111111111111111111
awk100: plait command line jukebox: http://stephenjungels.com/jungels.net/projects/plait/
new section: awk for databases
	qawk
  	http://victor-notes.com/qppro/awk.html
	dda for awk share/pdf/awkdda.awk
	Quick and Dirty Databases with Nice Output: AWK and Tex
	http://mail.google.com/mail/#label/awk.info/1204fa85039f07f7


html parser in awk
http://chiranth.blogspot.com/2007/02/using-awk-to-parse-html.html
- cocomo lc


===================

because it jsut doesn't matter
i have an ide: emacs.unix

i have development environment:
- version control, backed up onto the web
- discussion tools (a google news group, a wikispaces wiki, chat, email)
- test driven development (eg subdirectory with x.want files)
- library of functions stored in a directory, indexed by ctags
- emacs/vim ctags intergration means by code is hyperlinked by function name

what makes me productive is not the language, its the environment
- unix
- tdd

addict to tweaking
- smalltalk environment

because here are the factors that control software economics
- boehm

bcasue its principles other the code that matter
- algorhtms O(logn)

because i am not just doing but also constantly explainin to people what i have to do
- awk exels at the one off report
- if i wrote in other languages, i'd still be writing the reports with awk scripts

because i teach 3rd year students programming languages and they eat
awk quickly, chew smalltalk slower, and barph at lisp. the added power
and functionality of these languages confuses them.

because i do a lot of stochastic stuff and so i've given away overly complex algorithms
in favor of simpler stochastic ones

because i do a lot of data mining and i keep finding that simple bayes
approaches consistently do better than anything else- and bayes is a snap in awk (see awk)

----------------
becasue it drives yu to the core.
no time lost nterfacing to complex libraries. no clear data structure design. just do it.


our software development processes are too complex since we don't acknowledge the following fact. usually,
we dont know what we are doing. software development isn't some mathematical process of translating
requirements into an executable, then testing that executable against the requiremetns. instead,
we never really know the requirements cause we've never really looked hard at that part of the world
before and, when we doing, looking at it matures our understanding of it so now we are looking at something
else. premise of agile software development is that up to 50% of the requirements can change each month- a pace
of change that is anethema to traditional plan-based approaches.

even when we do know what we are doing, we don't tell our software what that is. worked a lot in
testing and the one problem i kept returning too is "where is the oracle?". the program has produced
output, now is that the right output? what is our expectations regarding the output? how can we
judge if this output is better than that? more importantly, given that we generate gigabytes of output
now (cloud computing , fast CPUs), how can we automatically judge all that output? 
usually, these questions have no answers cause there is no "ocacle" built into the system.

our premise is that "knowing what (and why) we are doing it" should be a primary concern, all the
way through the lifecycle. also, we should tell the program what and why it is doing what it is doing
so it can automtically judge how well it is doing it. further, if we know the what and why of the program,
this simplifies software development:

- simpler design: wholes and holes. let the machine fill in the gaps
- simpler testing, certification , etc etc

to test that thesis, here we are going to it as simple as possible. 

this is not tdd (well, at least not traditional tdd). tdd  is usually about
unit tests. here we do system-level testing to learn inputs that
are better/worse than others and allow the program to adjust itself

this is not ai (well, at least no traditional ai). we don't assume some
logic program and delcaractive constraints.  the "keys effect"
sugggests we don't need the overhead of all that- rather we can
apply it to standard object-oriented / procedural systems.

this is not agent-based systems (well, at least not traditional agent-based
systems). yes, we will model user goals and goal interaction and
negotiaton between goals. and we will represent beliefs, desires,
and intentions. but we will add in a lot of data mining technology
to reduce 


invisible code. shoul melt away. reveal all.
