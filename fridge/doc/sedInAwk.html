<h1><join>Sed in Awk</join></h1>
<p><em>Writing in <a href="http://groups.google.com/group/comp.lang.awk/msg/9e1d90e6c9c04c70">comp.lang.awk</a> 
Ed Morton ports numerous complex sed expressions to Awk:</em>
<p>
A comp.lang.awk author ask the question:
<ul>
<p>
I have a file that has a series of lists
<pre>
> (qqq)
> aaa 111
> bbb 222
</pre>
<p>
and I want to make it look like
<pre>
> aaa 111 (qqq)
> bbb 222 (qqq)
</pre>
</ul>
<p>
IMHO the clearest sed solution given was:
<pre>
> sed -e '
>    /^([^)]*)/{
>       h; # remember the (qqq) part
>       d
>    }

>    / [1-9][0-9]*$/{
>       G; # strap the (qqq) part to the list
>       s/\n/ /
>    }
> ' yourfile
</pre>
<p>
while the awk one was:
<pre>
> awk '/^\(/{ h=$0;next } { print $0,h }' file
</pre>
<p>
As I've said repeatedly, sed is an excellent tool for simple
substitutions on a single line. For anything else you should use awk,
perl, etc.
<p>
Having said that, let's take a look at the awk equivalents for the
posted sed examples below that are not simple substitutions on a single
line so people can judge for themselves (i.e. quietly - this is not a
contest and not a religious war!) which code is clearer, more
consistent, and more obvious. When reading this, just imagine yourself
having to figure out what the given script does in order to debug or
enhance it or write your own similar one later.
<p>
Note that in awk as in shell there are many ways to solve a problem so
I'm trying to stick to the solutions that I think would be the most
useful to a beginner since that's who'd be reading an examples page like
this, and without using any GNU awk extensions. Also note I didn't test
any of this but it's all pretty basic stuff so it should mostly be right.
<p>
For those who know absolutely nothing about awk, I think all you need to
know to understand the scripts below is that, like sed, it loops through
input files evaluating conditions against the current input record (a
line by default) and executing the actions you specify (printing the
current input record if none specified) if those conditions are true,
and it has the following pre-defined symbols:
<pre>
NR = Number or Records read so far
NF = Number of Fields in current record
FS = the Field Separator
RS = the Record Separator
BEGIN = a pattern that's only true before processing any input
END = a pattern that's only true after processing all input.
</pre>
<p>
Oh, and setting RS to the NULL string (-v RS='') tells awk to read
paragraphs instead of lines as individual records, and setting FS to the
NULL string (-v FS='') tells awk to treat each individual character as a
field.
<p>
For more info on awk, see http://www.awk.info.

<h2>Examples</h2>
<p>Double space a file:
<ul>
<p>Sed:
<pre>
> sed G
</pre>
<p>Awk
<pre>
awk '{print $0 "\n"}'
</pre>
</ul>
<p>
Double space a file which already has blank lines in it. Output file
should contain no more than one blank line between lines of text.
<ul>
<p>Sed:
<pre>
> sed '/^$/d;G'
</pre>
<p>Awk:
<pre>
awk 'NF{print $0 "\n"}'
</pre>
</ul>
<p>Triple space a file
<ul><p>Sed:<pre>
> sed 'G;G'
<p>Awk:<pre>
awk '{print $0 "\n\n"}'
</pre></ul>

> # undo double-spacing (assumes even-numbered lines are always blank)
> sed 'n;d'

awk 'NF'

> # insert a blank line above every line which matches "regex"
> sed '/regex/{x;p;x;}'

awk '{print (/regex/ ? "\n" : "") $0}'

> # insert a blank line below every line which matches "regex"
> sed '/regex/G'

awk '{print $0 (/regex/ ? "\n" : "")}'

> # insert a blank line above and below every line which matches "regex"
> sed '/regex/{x;p;x;G;}'

awk '{print (/regex/ ? "\n" $0 "\n" : $0)}'

> NUMBERING:

> # number each line of a file (simple left alignment). Using a tab (see
> # note on '\t' at end of file) instead of space will preserve margins.
> sed = filename | sed 'N;s/\n/\t/'

awk '{print NR "\t" $0}'

> # number each line of a file (number on left, right-aligned)
> sed = filename | sed 'N; s/^/     /; s/ *\(.\{6,\}\)\n/\1  /'

awk '{printf "%6s  %s\n",NR,$0}'

> # number each line of file, but only print numbers if line is not blank
> sed '/./=' filename | sed '/./N; s/\n/ /'

awk 'NF{print NR "\t" $0}'

> # count lines (emulates "wc -l")
> sed -n '$='

awk 'END{print NR}'

> TEXT CONVERSION AND SUBSTITUTION:

<simple substitutions on single line snipped>

> # align all text flush right on a 79-column width
> sed -e :a -e 's/^.\{1,78\}$/ &/;ta'  # set at 78 plus 1 space

awk '{printf "%79s\n",$0}'

> # center all text in the middle of 79-column width. In method 1,
> # spaces at the beginning of the line are significant, and trailing
> # spaces are appended at the end of the line. In method 2, spaces at
> # the beginning of the line are discarded in centering the line, and
> # no trailing spaces appear at the end of lines.
> sed  -e :a -e 's/^.\{1,77\}$/ & /;ta'                     # method 1
> sed  -e :a -e 's/^.\{1,77\}$/ &/;ta' -e 's/\( *\)\1/\1/'  # method 2

awk '{printf "%"int((79+length)/2)"s\n",$0}'

<simple substitutions on single line snipped>

> # reverse order of lines (emulates "tac")
> # bug/feature in HHsed v1.5 causes blank lines to be deleted
> sed '1!G;h;$!d'               # method 1
> sed -n '1!G;h;$p'             # method 2

awk '{a[NR]=$0} END{for (i=NR;i>=1;i--) print a[i]}'

> # reverse each character on the line (emulates "rev")
> sed '/\n/!G;s/\(.\)\(.*\n\)/&\2\1/;//D;s/.//'

awk -v FS='' '{for (i=NF;i>=1;i--) printf "%s",$i; print ""}'

> # join pairs of lines side-by-side (like "paste")
> sed '$!N;s/\n/ /'

awk '{printf "%s%s",$0,(NR%2 ? " " : "\n")}'

> # if a line ends with a backslash, append the next line to it
> sed -e :a -e '/\\$/N; s/\\\n//; ta'

awk '{printf "%s",(sub(/\\$/,"") ? $0 : $0 "\n")}'

> # if a line begins with an equal sign, append it to the previous line
> # and replace the "=" with a single space
> sed -e :a -e '$!N;s/\n=/ /;ta' -e 'P;D'

awk '{printf "%s%s",(sub(/^=/," ") ? "" : "\n"),$0} END{print ""}'

<simple substitutions on single line snipped>

> # add a blank line every 5 lines (after lines 5, 10, 15, 20, etc.)
> gsed '0~5G'                  # GNU sed only
> sed 'n;n;n;n;G;'             # other seds

awk '{print $0} !(NR%5){print ""}'

> SELECTIVE PRINTING OF CERTAIN LINES:

> # print first 10 lines of file (emulates behavior of "head")
> sed 10q

awk '{print $0} NR==10{exit}'

> # print first line of file (emulates "head -1")
> sed q

awk 'NR==1{print $0; exit}'

> # print the last 10 lines of a file (emulates "tail")
> sed -e :a -e '$q;N;11,$D;ba'

awk '{a[NR]=$0} END{for (i=NR-10;i<=NR;i++) print a[i]}'

> # print the last 2 lines of a file (emulates "tail -2")
> sed '$!N;$!D'

awk '{a[NR]=$0} END{for (i=NR-2;i<=NR;i++) print a[i]}'

> # print the last line of a file (emulates "tail -1")
> sed '$!d'                    # method 1
> sed -n '$p'                  # method 2

awk 'END{print $0}'

> # print the next-to-the-last line of a file
> sed -e '$!{h;d;}' -e x  # for 1-line files, print blank line
> sed -e '1{$q;}' -e '$!{h;d;}' -e x  # for 1-line files, print the line
> sed -e '1{$d;}' -e '$!{h;d;}' -e x  # for 1-line files, print nothing

awk '{prev=curr; curr=$0} END{print prev}'

> # print only lines which match regular expression (emulates "grep")
> sed -n '/regexp/p'           # method 1
> sed '/regexp/!d'             # method 2

awk '/regexp/'

> # print only lines which do NOT match regexp (emulates "grep -v")
> sed -n '/regexp/!p'          # method 1, corresponds to above
> sed '/regexp/d'              # method 2, simpler syntax

awk '!/regexp/'

> # print the line immediately before a regexp, but not the line
> # containing the regexp
> sed -n '/regexp/{g;1!p;};h'

awk '/regexp/{print prev} {prev=$0}'

> # print the line immediately after a regexp, but not the line
> # containing the regexp
> sed -n '/regexp/{n;p;}'

awk 'found{print $0} {found=(/regexp/ ? 1 : 0)}'

> # print 1 line of context before and after regexp, with line number
> # indicating where the regexp occurred (similar to "grep -A1 -B1")
> sed -n -e '/regexp/{=;x;1!p;g;$!N;p;D;}' -e h

awk 'found    {print preLine "\n" hitLine "\n" $0;   found=0}
      /regexp/ {preLine=prev;   hitLine=NR " " $0;    found=1}
      {prev=$0}'

> # grep for AAA and BBB and CCC (in any order)
> sed '/AAA/!d; /BBB/!d; /CCC/!d'

awk '/AAA/&&/BBB/&&/CCC/'

> # grep for AAA and BBB and CCC (in that order)
> sed '/AAA.*BBB.*CCC/!d'

awk '/AAA.*BBB.*CCC/'

> # grep for AAA or BBB or CCC (emulates "egrep")
> sed -e '/AAA/b' -e '/BBB/b' -e '/CCC/b' -e d    # most seds
> gsed '/AAA\|BBB\|CCC/!d'                        # GNU sed only

awk '/AAA|BBB|CCC/'

> # print paragraph if it contains AAA (blank lines separate paragraphs)
> # HHsed v1.5 must insert a 'G;' after 'x;' in the next 3 scripts below
> sed -e '/./{H;$!d;}' -e 'x;/AAA/!d;'

awk -v RS='' '/AAA/'

> # print paragraph if it contains AAA and BBB and CCC (in any order)
> sed -e '/./{H;$!d;}' -e 'x;/AAA/!d;/BBB/!d;/CCC/!d'

awk -v RS='' '/AAA/&&/BBB/&&/CCC/'

> # print paragraph if it contains AAA or BBB or CCC
> sed -e '/./{H;$!d;}' -e 'x;/AAA/b' -e '/BBB/b' -e '/CCC/b' -e d
> gsed '/./{H;$!d;};x;/AAA\|BBB\|CCC/b;d'         # GNU sed only

awk -v RS='' '/AAA|BBB|CCC/'

> # print only lines of 65 characters or longer
> sed -n '/^.\{65\}/p'

awk -v FS='' 'NF>=65'

> # print only lines of less than 65 characters
> sed -n '/^.\{65\}/!p'        # method 1, corresponds to above
> sed '/^.\{65\}/d'            # method 2, simpler syntax

awk -v FS='' 'NF<65'

> # print section of file from regular expression to end of file
> sed -n '/regexp/,$p'

awk '/regexp/{found=1} found'

> # print section of file based on line numbers (lines 8-12, inclusive)
> sed -n '8,12p'               # method 1
> sed '8,12!d'                 # method 2

awk 'NR>=8 && NR<=12'

> # print line number 52
> sed -n '52p'                 # method 1
> sed '52!d'                   # method 2
> sed '52q;d'                  # method 3, efficient on large files

awk 'NR==52{print $0; exit}'

> # beginning at line 3, print every 7th line
> gsed -n '3~7p'               # GNU sed only
> sed -n '3,${p;n;n;n;n;n;n;}' # other seds

awk '!((NR-3)%7)'

> # print section of file between two regular expressions (inclusive)
> sed -n '/Iowa/,/Montana/p'             # case sensitive

awk '/Iowa/,/Montana/'

>> Print all lines of FileID upto 1st line containing

> sed '/string/q' FileID

awk '{print $0} /string/{exit}'

>> Print all lines of FileID from 1st line containing
>>      until eof

> sed '/string/,$!d' FileID

awk '/string/{found=1} found'

>>  Print all lines of FileID from 1st line containing
>>      until 1st line containing   [boundries inclusive]

> sed '/string1/,$!d;/string2/q' FileID

awk '/string1/{found=1} found{print $0} /string2/{exit}'

> SELECTIVE DELETION OF CERTAIN LINES:

> # print all of file EXCEPT section between 2 regular expressions
> sed '/Iowa/,/Montana/d'

awk '/Iowa/,/Montana/{next} {print $0}' file

> # delete duplicate, consecutive lines from a file (emulates "uniq").
> # First line in a set of duplicate lines is kept, rest are deleted.
> sed '$!N; /^\(.*\)\n\1$/!P; D'

awk '$0!=prev{print $0} {prev=$0}'

> # delete duplicate, nonconsecutive lines from a file. Beware not to
> # overflow the buffer size of the hold space, or else use GNU sed.
> sed -n 'G; s/\n/&&/; /^\([ -~]*\n\).*\n\1/d; s/\n//; h; P'

awk '!a[$0]++'

> # delete all lines except duplicate lines (emulates "uniq -d").
> sed '$!N; s/^\(.*\)\n\1$/\1/; t; D'

awk '$0==prev{print $0} {prev=$0}'      # works only on consecutive
awk 'a[$0]++'                           # works on non-consecutive

> # delete the first 10 lines of a file
> sed '1,10d'

awk 'NR>10'

> # delete the last line of a file
> sed '$d'

awk 'NR>1{print prev} {prev=$0}'

> # delete the last 2 lines of a file
> sed 'N;$!P;$!D;$d'

awk 'NR>2{print prev[2]} {prev[2]=prev[1]; prev[1]=$0}'    # method 1
awk '{a[NR]=$0} END{for (i=i;i<=NR-2;i++) print a[i]}'     # method 2
awk -v num=2 'NR>num{print prev[num]}
    {for (i=num;i>1;i--) prev[i]=prev[i-1]; prev[1]=$0}'    # method 3

> # delete the last 10 lines of a file
> sed -e :a -e '$d;N;2,10ba' -e 'P;D'   # method 1
> sed -n -e :a -e '1,10!{P;N;D;};N;ba'  # method 2

awk -v num=10 '...same as deleting last 2 method 3 above...'

> # delete every 8th line
> gsed '0~8d'                           # GNU sed only
> sed 'n;n;n;n;n;n;n;d;'                # other seds

awk 'NR%8'

> # delete lines matching pattern
> sed '/pattern/d'

awk '!/pattern/'

> # delete ALL blank lines from a file (same as "grep '.' ")
> sed '/^$/d'                           # method 1
> sed '/./!d'                           # method 2

awk '!/^$/'                             # method 1
awk '/./'                               # method 2

> # delete all CONSECUTIVE blank lines from file except the first; also
> # deletes all blank lines from top and end of file (emulates "cat -s")
> sed '/./,/^$/!d'          # method 1, allows 0 blanks at top, 1 at EOF

awk '/./,/^$/'

> sed '/^$/N;/\n$/D'        # method 2, allows 1 blank at top, 0 at EOF

no idea what the point of this is - I suspect someone just typed this by
accident when trying to solve a different problem and then noticed what
it does and decided to document it.

> # delete all CONSECUTIVE blank lines from file except the first 2:
> sed '/^$/N;/\n$/N;//D'

again, apparently pointless and would need some in/out to figure out
what it really means.

> # delete all leading blank lines at top of file
> sed '/./,$!d'

awk 'NF{found=1} found'

> # delete all trailing blank lines at end of file
> sed -e :a -e '/^\n*$/{$d;N;ba' -e '}'  # works on all seds
> sed -e :a -e '/^\n*$/N;/\n$/ba'        # ditto, except for gsed 3.02.*

awk '{a[NR]=$0} NF{nbNr=NR} END{for (i=1;i<=nbNr;i++) print a[i]}'

> # delete the last line of each paragraph
> sed -n '/^$/{p;h;};/./{x;/./p;}'

awk -v FS='\n' -v RS='' '{for (i=1;i<=NF;i++) print $i; print ""}'

> SPECIAL APPLICATIONS:

<simple substitutions on single line snipped>

> # get Usenet/e-mail message header
> sed '/^$/q'        # deletes everything after first blank line

awk '/^$/{exit}'

> # get Usenet/e-mail message body
> sed '1,/^$/d'              # deletes everything up to first blank line

awk 'found{print $0} /^$/{found=1}'

> # get Subject header, but remove initial "Subject: " portion
> sed '/^Subject: */!d; s///;q'

awk 'sub(/Subject: */,"")'

> # get return address header
> sed '/^Reply-To:/q; /^From:/h; /./d;g;q'

can't tell from the comment what this specifically does to the text and
not worth the effort to figure out what the chains of hs, qs, gs and
semicolons mean.

> # parse out the address proper. Pulls out the e-mail address by itself
> # from the 1-line return address header (see preceding script)
> sed 's/ *(.*)//; s/>.*//; s/.*[:<] *//'

awk '{sub(/ *\(.*\)/,""); sub(/>.*/,""); sub(/.*[:<] */,""); print $0}'

> # add a leading angle bracket and space to each line (quote a message)
> sed 's/^/> /'

awk '{print "> " $0}'

> # delete leading angle bracket & space from each line (unquote
> a message)
> sed 's/^> //'

awk '{sub(/> /,""); print $0}'

> # remove most HTML tags (accommodates multiple-line tags)
> sed -e :a -e 's/<[^>]*>//g;/</N;//ba' 
