     1	|   From: tim@menzies.us
     2	|   Newsgroups: comp.lang.awk,comp.unix.shell,comp.answers,news.answers 
     3	|   Followup-To: poster 
     4	|   Subject: Awk FAQ v2.0 
     5	|   Summary: FAQ (Frequently Asked Questions) about the awk programming language
     6	|   Last-modified: 2010-Jan-20
     7	|   Version: 2.0
     8	|   URL: http://awk.info/faq.txt
     9	|   Archive-name:  http://awk.info/faq.txt
    10	|   
    11	|   Frequently Asked Questions == FAQ
    12	|   
    13	|   The FAQ list for comp.lang.awk can be found on the Internet:
    14	|     <http://awk.info/faq.txt>
    15	|     <http://www.faqs.org/faqs/computer-lang/awk/faq/>
    16	|   
    17	|   ========================================================================
    18	|   
    19	|   Contents:
    20	|   
    21	|      1. Disclaimer
    22	|      2. Spam
    23	|      3. Can you answer my awk question?
    24	|      4. How can I add a FAQ and its answer to the FAQ list?
    25	|      5. What is awk?
    26	|      6. What well-maintained awk-compatible languages are there?
    27	|         6.1 nawk
    28	|         6.2 gawk
    29	|         6.3 mawk
    30	|         6.4 xgawk
    31	|         6.5 sqawk
    32	|         6.6 jawk
    33	|         6.7 runawk
    34	|         6.8 older version
    35	|      7. Where can I buy awk?
    36	|      8. Where can I get awk for free?  For what platforms?
    37	|         8.1 OS/X
    38	|         8.2 Windows
    39	|         8.3 LINUX
    40	|      9. Why would anyone use awk instead of language XYZ?
    41	|     10. How can I learn awk?
    42	|     11. What are some other awk resources?
    43	|         11.1. The awk community portal.
    44	|         11.2. Short tutorials for newcomers.
    45	|         11.3. Longer Tutorials.
    46	|         11.4. Arnold Robbins' collection  
    47	|     12. How do I report a bug in gawk?
    48	|     13. How can I access shell or environment variables in an awk script?
    49	|     14. How does awk deal with multiple files?
    50	|         14.1 How can awk test for the existence of a file?
    51	|         14.2 How can I get awk to read multiple files?
    52	|         14.3 How can I tell from which file my input is coming?
    53	|         14.4 How can I get awk to open multiple files (selected at runtime)?
    54	|         14.5 How can I treat the first file specially?
    55	|         14.6 How can I explicitly pass in a filename to treat specially?
    56	|     15. How many elements were created by split()?
    57	|     16. How can I split a string into characters?
    58	|     17. How do I have dynamic-width printf strings, like C?
    59	|     18. Why doesn't "\\$" behave like /\\$/ ?  Why don't parentheses match?
    60	|     19. What is awk's exit code?
    61	|     20. How can I get awk to be case-insensitive?
    62	|         20.1. use tolower()
    63	|         20.2. use IGNORECASE=1
    64	|     21. How can I force a numeric/non-numeric comparison?
    65	|     22. Why does { FS=":"; print $1 } not split the first record?
    66	|     23. Did ^ and $ and . change in gawk?
    67	|     24. Why doesn't awk 'begin {...}' work?
    68	|     25. Why does awk 'BEGIN { print 6 " " -22 }' lose the space?
    69	|     26. How do I take advantage of gawk's networking support?
    70	|     98. Miscellaneous
    71	|     99. Credits
    72	|   
    73	|   ========================================================================
    74	|   
    75	|   1. Disclaimer
    76	|   
    77	|   Read at your own risk.  The current, previous, or original authors
    78	|   make no claim as to fitness for any purpose or absence of any errors,
    79	|   and offer no warranty.  Do not eat.
    80	|   
    81	|   ========================================================================
    82	|   
    83	|   2. Spam
    84	|   
    85	|   You wouldn't believe how much spam I get to this address.
    86	|   
    87	|   ========================================================================
    88	|   
    89	|   3. Can you answer my awk question?
    90	|   
    91	|   Probably not.  Please don't mail it to me.
    92	|   
    93	|   Read the FAQ, and the materials pointed to by it, and if you can't find
    94	|   an answer there, by all means post to the newsgroup.
    95	|   
    96	|   If you need help posting, see <http://groups.google.com/> among others.
    97	|   
    98	|   A FAQ list is intended to reduce traffic on a newsgroup, not eliminate it.
    99	|   
   100	|   ========================================================================
   101	|   
   102	|   4. How can I add a FAQ and its answer to the FAQ list?
   103	|   
   104	|   Mail BOTH of them to me.  Then I can add them to the FAQ and it should
   105	|   help people who have that same question later, as well as everyone who
   106	|   reads the group, because they won't see it asked and answered so often.
   107	|   
   108	|   I do not work on this FAQ every day, but I will try to get updates
   109	|   incorporated in a timely manner (say, monthly).
   110	|   
   111	|   Of course, don't mail me my entire FAQ!  I already have a copy!  There
   112	|   are copies available all over the web that I could use if I lost mine!
   113	|   I pay for my access; don't you?
   114	|     
   115	|   ========================================================================
   116	|   
   117	|   5. What is awk?
   118	|   
   119	|   Awk is a stable, cross platform computer language named for its
   120	|   authors Alfred Aho, Peter Weinberger & Brian Kernighan. They write:
   121	|   "Awk is a convenient and expressive programming language that can
   122	|   be applied to a wide variety of computing and data-manipulation
   123	|   tasks".
   124	|   
   125	|     Alfred V. Aho
   126	|     Brian W. Kernighan
   127	|     Peter J. Weinberger
   128	|   
   129	|   In Classic Shell Scripting, Arnold Robbins & Nelson Beebe confess
   130	|   their Awk bias: "We like it. A lot. The simplicity and power of Awk
   131	|   often make it just the right tool for the job."
   132	|   
   133	|   Besides the Bourne shell, Awk is the only other scripting language
   134	|   available in the standard Unix environment. Implementations of AWK
   135	|   exist as installed software for almost all other operating systems.
   136	|   
   137	|   ========================================================================
   138	|   
   139	|   6. What well-maintained awk-compatible languages are there?
   140	|   
   141	|     6.1 nawk
   142	|       "The one true awk", old.
   143	|       Interpreter.
   144	|       See http://www.cs.princeton.edu/~bwk/btl.mirror/awk.tar.gz
   145	|   
   146	|     6.2 gawk
   147	|       From the GNU project.
   148	|       Widely used.
   149	|       Interpreter.
   150	|       See http://www.gnu.org/software/gawk/
   151	|   
   152	|     6.3 mawk
   153	|   	Mike's Awk  (from Michael Brennan).
   154	|   	For some code, runs very fast.
   155	|       Interpreter
   156	|   	See http://freshmeat.net/projects/mawk/
   157	|   
   158	|     6.4 xgawk
   159	|       Gawk + XML + ...
   160	|       Interpreter
   161	|       See http://home.vrweb.de/~juergen.kahrs/gawk/XML/.
   162	|   
   163	|     6.5 sqawk
   164	|       Gawk + SQL
   165	|   	Interpreter
   166	|   	See http://code.google.com/p/spawk/.
   167	|   
   168	|     6.6 jawk
   169	|   	Awk in the JAVA virtual machine
   170	|   	Interpreter.
   171	|   	See http://jawk.sourceforge.net/.
   172	|   
   173	|     6.7 runawk
   174	|       A wrapper for the AWK interpreter, providing modules 
   175	|   	See http://sourceforge.net/projects/runawk/files/runawk/.
   176	|   
   177	|     6.8 Older versions, may not be currently supported, translates to "C".
   178	|   	 * awk2c
   179	|        * awka
   180	|   
   181	|   ========================================================================
   182	|   
   183	|   7. Where can I buy awk?
   184	|   
   185	|   AFAIK, all current AWK versions are open source; i.e. free.
   186	|   
   187	|   ========================================================================
   188	|   
   189	|   8. Where can I get awk for free?  For what platforms?
   190	|   
   191	|   AFAIK, all current AWK versions are open source; i.e. free.
   192	|   
   193	|   AWK runs on many platforms and can be downloaded and installed from
   194	|   many package management systems; e.g.
   195	|   
   196	|     8.1. OS/X
   197	|          From FINK: http://www.finkproject.org/
   198	|          From darwin ports: http://darwinports.com/
   199	|     8.2. Windows
   200	|   	   From GnuWin32: http://gnuwin32.sourceforge.net/
   201	|   	   From Cygwin: http://www.cygwin.com/
   202	|     8.3.  LINUX:
   203	|   	   From apt-get: from e.g. the Synaptic package manager.
   204	|   
   205	|   ========================================================================
   206	|   
   207	|   9. Why would anyone use awk instead of language XYZ?
   208	|   
   209	|   Awk is a simple and elegant pattern scanning and processing language.
   210	|   Awk is also the most portable scripting language in existence.
   211	|   But why use it rather than Perl (or PHP or Ruby or...):
   212	|   
   213	|     - Awk is simpler (especially important if deciding which to learn
   214	|       first);
   215	|     - Awk syntax is far more regular (another advantage for the
   216	|       beginner, even without considering syntax-highlighting editors);
   217	|     - You may already know Awk well enough for the task at hand;
   218	|     - You may have only Awk installed;
   219	|     - Awk can be smaller, thus much quicker to execute for small programs.
   220	|   
   221	|   Tom Christiansen wrote in Message-ID: <3766d75e@cs.colorado.edu>
   222	|     > Awk is a venerable, powerful, elegant, and simple tool that everyone
   223	|     > should know.  (Languages like) Perl are a superset and child of awk, 
   224	|     > but has much more power that comes at expense of sacrificing some 
   225	|     > of that simplicity.
   226	|   
   227	|   Carlo Strozzi writes:
   228	|   
   229	|     (Other languages like Perl is) a good programming language for writing
   230	|     self-contained programs, but pre-compilation and long start-up time
   231	|     are worth paying only if once the program has loaded it can do
   232	|     everything in one go. This contrasts sharply with the Operator-stream
   233	|     Paradigm, where operators are chained together in pipelines of two,
   234	|     three or more programs. The overhead associated with initializing
   235	|     (say) Perl at every stage of the pipeline makes pipelining
   236	|     inefficient. A better way of manipulating structured ASCII files is to
   237	|     use the AWK programming language, which is much smaller, more
   238	|     specialized for this task, and is very fast at startup.
   239	|   
   240	|   ========================================================================
   241	|   
   242	|   10. How can I learn awk?
   243	|   
   244	|     English Book:
   245	|   
   246	|         _The AWK Programming Language_, by Aho, Kernighan and Weinberger,
   247	|         who invented the language.  Published by Addison-Wesley.  Lots of
   248	|         good material in not a lot of space.  Out of date, with regard to 
   249	|         POSIX awk.
   250	|   
   251	|         ISBN 0-201-07981-X
   252	|   
   253	|         Source code: 
   254	|         <http://lawker.googlecode.com/svn/fridge/lib/awk/theAwkBook/>
   255	|   
   256	|     English Book:
   257	|   
   258	|         _Effective Awk Programming_, by Arnold Robbins
   259	|         published by O'Reilly and Associates.
   260	|   
   261	|         ISBN 0-596-00070-7 (third edition)
   262	|   
   263	|         <http://www.oreilly.com/catalog/awkprog3/>
   264	|         <http://www.gnu.org/manual/gawk>
   265	|   
   266	|         Errata:
   267	|   		<http://oreilly.com/catalog/awkprog3/errata/>
   268	|   
   269	|         We recommends buying the book instead of trying to print it
   270	|         all out, for three reasons:
   271	|   
   272	|           1. It's probably cheaper than using your own toner and paper.
   273	|   
   274	|           2. Some money goes back to help further development, both to
   275	|              Arnold Robbins (only if you buy from ORA) and the Free
   276	|              Software Foundation (if you buy from either ORA or the FSF).
   277	|   
   278	|           3. It helps convince publishers that we _like_ having full
   279	|              documentation available on-line (e.g., for searching), but
   280	|              will still pay for a compact, bound copy.
   281	|   
   282	|     English reference card:
   283	|   
   284	|         <http://lawker.googlecode.com/svn/fridge/share/pdf/awkcard.pdf>
   285	|   
   286	|     English Book:
   287	|   
   288	|         second edition:
   289	|   
   290	|         _Sed & Awk_, by Dale Dougherty & Arnold Robbins, published
   291	|         by O'Reilly and Associates.
   292	|   
   293	|         ISBN 1-56592-225-5 (second edition)
   294	|   
   295	|         _sed & awk_ describes two text manipulation programs that are
   296	|         mainstays of the UNIX programmer's toolbox.  This new edition
   297	|         covers the sed and awk programs as they are now mandated by
   298	|         the POSIX standard and includes discussion of the GNU versions
   299	|         of these programs.
   300	|   
   301	|         <http://www.ora.com/catalog/sed2/>
   302	|   
   303	|         An errata for the second edition of Sed & Awk is at
   304	|   
   305	|         <http://oreilly.com/catalog/sed2/errata/>
   306	|   
   307	|     English Book:
   308	|   
   309	|         _Classic Shell Scripting_ by Arnold Robbins and Nelson Beebe
   310	|         published by O'Reilly and Associates.
   311	|      
   312	|         ISBN 5-9600-595-4
   313	|   
   314	|         Contains an (excellent) short introduction to Gawk, as well
   315	|         as numerous other UNIX shell languages that can be combined
   316	|         to quickly build applications.
   317	|   
   318	|         <http://oreilly.com/catalog/9780596005955/>
   319	|   
   320	|         An errata for this book is at
   321	|   
   322	|         <http://oreilly.com/catalog/errata.csp?isbn=9780596005955>
   323	|   
   324	|     English Book:
   325	|   
   326	|         _Mastering Regular Expressions_, by Jeffrey E.F. Friedl, published
   327	|         by O'Reilly and Associates.  (the `Hip Owls Book')
   328	|   
   329	|         ``... you will learn how to use regular expressions to
   330	|         solve problems and get the most out of tools that provide
   331	|         them.  Not only that, but much more:  this book is about
   332	|         _mastering_ regular expressions.''
   333	|   
   334	|         <http://www.ora.com/catalog/regex/>
   335	|   
   336	|         errata, additions, change log available at the author's home page
   337	|         <http://public.yahoo.com/~jfriedl/regex/>
   338	|   
   339	|         ISBN 1-56592-257-3
   340	|   
   341	|     Deutsch Book:
   342	|   
   343	|         Friedl's _Mastering Regular Expressions_.
   344	|   
   345	|         <http://www.oreilly.de/catalog/regexger/index.html>
   346	|   
   347	|     Japanese Book:
   348	|   
   349	|        _Grep,Sed,Awk_ by Akihiro Miyoshi
   350	|        ISBN  4-87966-794-3
   351	|        June 1998 264 pages
   352	|        Shuwa System Manual & Reference Series
   353	|        <http://www.shuwasystem.co.jp/books/wwwsrch/cgi-bin/content/794/index.htm>
   354	|        Serves both as a tutorial and a manual. Divided quite evenly into three
   355	|        parts. Regular expressions explored in detail in grep section.
   356	|   
   357	|     English Booklet:
   358	|   
   359	|       TCP/IP Internetworking With Gawk
   360	|       ISBN 1-882114-93-0
   361	|       <http://home.vr-web.de/Juergen.Kahrs/gawk/gawkinet.html>
   362	|   
   363	|       An abridged form is included in O'Reilly's Effective Awk Programming 3e
   364	|   
   365	|       A short worked example of this code is at http://awk.info/?tools/server.
   366	|   
   367	|   ==========================================================================
   368	|   
   369	|   11. What are some other awk resources?
   370	|   
   371	|     11.1. The awk community portal: a large collection of awk tips and trips.
   372	|        <http://awk.info>
   373	|   
   374	|     11.2. Short tutorials for newcomers.  Sorted by newbie-ness 
   375	|        (so best to start at the top):
   376	|        
   377	|        Eric Wendelin: Awk is a beautiful tool
   378	|        <http://eriwen.com/tools/awk-is-a-beautiful-tool/>
   379	|        
   380	|        Tim Sherwood: AWK: The Duct Tape of Computer Science Research (slides)
   381	|        <http://lawker.googlecode.com/svn/fridge/share/pdf/gawk-tutorial.pdf>
   382	|        
   383	|        Ronald Loui: Samples of Gawk
   384	|        <http://awk.info/?samples>
   385	|        
   386	|        Andrew Ross: Getting started with awk
   387	|        <http://doc.ddart.net/shell/awk/>
   388	|        
   389	|        Tim Menzies: Four Keys to Gawk
   390	|        <http://awk.info/?keys2awk>
   391	|        
   392	|        Peteris Krumins: 10 Awk Tips, Tricks and Pitfalls
   393	|        <http://www.catonmat.net/blog/ten-awk-tips-tricks-and-pitfalls/>
   394	|        
   395	|        Paul Jakma: Awk programmers' FAQ
   396	|        <http://hibernia.jakma.org/~paul/awk-faq.html>
   397	|        
   398	|        Ed Morton (and friends): Use (and Abuse) of Getline
   399	|        <http://awk.info/?tip/getline>
   400	|        
   401	|     11.3. Longer Tutorials
   402	|        
   403	|        The following list is sorted by the number of times this material 
   404	|        is tagged at delicious.com (most tagged at top):
   405	|        
   406	|        Greg Goebel: An Awk Primer
   407	|        <http://www.vectorsite.net/tsawk.html>
   408	|        
   409	|        Bruce Barnett: Awk - A Tutorial and Introduction
   410	|        <http://www.grymoire.com/Unix/Awk.html>
   411	|        
   412	|        Arnold Robbins: The GNU Awk User's Guide
   413	|        <http://www.gnu.org/software/gawk/manual/gawk.html>
   414	|        
   415	|        Emmett Dulaney: AWK: The Linux Administrators' Wisdom Kit
   416	|        <http://www.oracle.com/technology/pub/articles/dulaney_awk.html>
   417	|     
   418	|     11.4. Arnold Robbins' collection
   419	|   
   420	|         <ftp://ftp.freefriends.org/arnold/Awkstuff/>
   421	|   
   422	|         > A collection of awk related stuff that I'm starting and willing
   423	|         > to maintain.  Currently includes Henry Spencer's awf and aaa
   424	|         > programs, Brian Kernighan's chem, and Nelson Beebe's awkpretty,
   425	|         > and some smaller items.
   426	|   
   427	|   ========================================================================
   428	|   
   429	|   12. How do I report a bug in gawk?
   430	|   
   431	|   This is described in great detail in the gawk documentation.  In brief:
   432	|   
   433	|      1. Make sure what you've discovered is really a bug by checking
   434	|         the documentation and, if possible, comparing with nawk and mawk.
   435	|   
   436	|      2. Cut down the program and data to as small as possible a test
   437	|         case that will illustrate the bug.
   438	|   
   439	|      3. Optionally post to comp.lang.awk; this allows others to confirm
   440	|         or deny the behavior, and its incorrectness (or lack thereof).
   441	|   
   442	|      4. Send mail to <mailto:bug-gawk@gnu.org>.  This automatically sends
   443	|         a copy to Arnold Robbins.  Do not JUST post in comp.lang.awk;
   444	|         Arnold's readership there is sporadic, and of course any Usenet
   445	|         article can be missed, killed, or dropped.
   446	|   
   447	|   ========================================================================
   448	|   
   449	|   13. How can I access shell or environment variables in an awk script?
   450	|   
   451	|      Short answer = either of these, where "svar" is a shell variable
   452	|      and "avar" is an awk variable:
   453	|   
   454	|           awk -v avar="$svar" '... avar ...' file
   455	|           awk 'BEGIN{avar=ARGV[1];ARGV[1]=""}... avar ...' "$svar" file
   456	|   
   457	|      depending on your requirements for handling backslashes and
   458	|      handling ARGV[] if it contains a null string (see below for details).
   459	|   
   460	|      Long answer = There are several ways of passing the values of
   461	|      shell variables to awk scripts depending on which version of awk
   462	|      (and to a much lesser extent which OS) you're using. For this
   463	|      discussion, we'll consider the following 4 awk versions:
   464	|   
   465	|      oawk (old awk, /usr/bin/awk and /usr/bin/oawk on Solaris)
   466	|      nawk (new awk, /usr/bin/nawk on Solaris)
   467	|      sawk (non-standard name for /usr/xpg4/bin/awk on Solaris)
   468	|      gawk (GNU awk, downloaded from http://www.gnu.org/software/gawk)
   469	|   
   470	|      If you wanted to find all lines in a given file that match text
   471	|      stored in a shell variable "svar" then you could use one of the
   472	|      following:
   473	|   
   474	|      a) awk -v avar="$svar" '$0 == avar' file
   475	|      b) awk -vavar="$svar" '$0 == avar' file
   476	|      c) awk '$0 == avar' avar="$svar" file
   477	|      d) awk 'BEGIN{avar=ARGV[1];ARGV[1]=""}$0 == avar' "$svar" file
   478	|      e) awk 'BEGIN{avar=ARGV[1];ARGC--}$0 == avar' "$svar" file
   479	|      f) svar="$svar" awk 'BEGIN{avar=ENVIRON["svar"]}$0 == avar' file
   480	|      g) awk '$0 == '"$svar"'' file
   481	|   
   482	|      The following list shows which version is supported by which
   483	|      awk on Solaris (which should also apply to most other OSs):
   484	|   
   485	|           oawk = c, g
   486	|           nawk = a, c, d, f, g
   487	|           sawk = a, c, d, f, g
   488	|           gawk = a, b, c, d, f, g
   489	|   
   490	|      Notes:
   491	|   
   492	|      1) Old awk only works with forms "c" and "g", both of which have
   493	|         problems.
   494	|   
   495	|      2) GNU awk is the only one that works with form "b" (no space
   496	|         between "-v" and "var="). Since gawk also supports form "a",
   497	|         as do all the other new awks, you should avoid form "b" for
   498	|         portability between newer awks.
   499	|   
   500	|      3) In form "c", ARGV[1] is still getting populated, but
   501	|         because it contains an equals sign (=), awk changes it's normal
   502	|         behavior of assuming that arguments are file names and now instead
   503	|         assumes this is a variable assignment so you don't need to clear
   504	|         ARGV[1] as in form "d".
   505	|   
   506	|      4) In light of "3)" above, this raises the interesting question of
   507	|         how to pass awk a file name that contains an equals sign - the
   508	|         answer is to do one of the following:
   509	|   
   510	|          i) Specify a path, e.g. for a file named "abc=def" in the
   511	|             current directory, you'd use:
   512	|   
   513	|                   awk '...' ./abc=def
   514	|   
   515	|             Note that that won't work with older versions of gawk or with
   516	|             sawk.
   517	|   
   518	|         ii) Redirect the input from a file so it's opend by the shell
   519	|             rather than awk having to parse the file name as an argument
   520	|             and then open it:
   521	|   
   522	|                   awk '...' < abc=def
   523	|   
   524	|             Note that you will not have access to the file name in the
   525	|             FILENAME variable in this case.
   526	|   
   527	|      5) An alternative to setting ARGV[1]="" in form "d" is to delete
   528	|         that array entry, e.g.:
   529	|   
   530	|           awk 'BEGIN{avar=ARGV[1];delete ARGV[1]}$0 == avar' "$svar" file
   531	|   
   532	|         This is slightly misleading, however since although ARGV[1]
   533	|         does get deleted in the BEGIN section and remains deleted
   534	|         for any files that preceed the deleted variable assignment,
   535	|         the ARGV[] entry is recreated by awk when it gets to that
   536	|         argument during file processing, so in the case above when
   537	|         parsing "file", ARGV[1] would actually exist with a null
   538	|         string value just like if you'd done ARGV[1]="". Given that
   539	|         it's misleading and introduces inconsistency of ARGV[]
   540	|         settings between files based on command-line order, it is
   541	|         not recommended.
   542	|   
   543	|      6) An alternative to setting svar="$svar" on the command line
   544	|         prior to invoking awk in form "f" is to export svar first,
   545	|         e.g.:
   546	|   
   547	|           export svar
   548	|           awk 'BEGIN{avar=ENVIRON["svar"]}$0 == avar' file
   549	|   
   550	|         Since this forces you to export variables that you wouldn't
   551	|         normally export and so risk interfering with the environment
   552	|         of other commands invoked from your shell, it is not recommended.
   553	|   
   554	|      7) When you use form "d", you end up with a null string in
   555	|         ARGV[1], so if at the end of your program you want to print
   556	|         out all the file names then instead of doing:
   557	|   
   558	|           END{for (i in ARGV) print ARGV[i]}
   559	|   
   560	|         you need to check for a null string before printing. or
   561	|         store FILENAMEs in a different array during processing.
   562	|         Note that the above loop as written would also print the
   563	|         script name stored in ARGV[0].
   564	|   
   565	|      8) When you use form "a", "b", or "c", the awk variable
   566	|         assignment gets processed during awks lexical analaysis
   567	|         stage (i.e. when the internal awk program gets built) and
   568	|         any backslashes present in the shell variable may get
   569	|         expanded so, for example, if svar contains "hi\there"
   570	|         then avar could contain "hi<tab>there" with a literal tab
   571	|         character. This behavior depends on the awk version as
   572	|         follows:
   573	|   
   574	|         oawk: does not print a warning and sets avar="hi\there"
   575	|         sawk: does not print a warning and sets avar="hi<tab>here"
   576	|         nawk: does not print a warning and sets avar="hi<tab>here"
   577	|         gawk: does not print a warning and sets avar="hi<tab>here"
   578	|   
   579	|         If the backslash preceeds a character that has no
   580	|         special meaning to awk then the backslash may be discarded
   581	|         with or without a warning, e.g. if svar contained "hi\john"
   582	|         then the backslash preceeds "j" and "\j" has no special
   583	|         meaning so the various new awks each would behave differently
   584	|         as follows:
   585	|   
   586	|         oawk: does not print a warning and sets avar="hi\john"
   587	|         sawk: does not print a warning and sets avar="hi\john"
   588	|         nawk: does not print a warning and sets avar="hijohn"
   589	|         gawk: prints a warning and sets avar="hijohn"
   590	|   
   591	|      9) None of the awk versions discussed here work with form "e" but
   592	|         it is included above as there are older (i.e. pre-POSIX) versions
   593	|         of awk that will treat form "d" as if it's intended to access a
   594	|         file named "" so you instead need to use form "e". If you find
   595	|         yourself with that or any other version of "old awk", you need
   596	|         to get a new awk to avoid future headaches and they will not be
   597	|         discussed further here.
   598	|   
   599	|      So, the forms accepted by all 3 newer awks under discussion (nawk,
   600	|      sawk, and gawk) are a, c, d, f, and g. The main differences between
   601	|      each of these forms is as follows:
   602	|   
   603	|         |-------|-------|----------|-----------|-----------|--------|
   604	|         | BEGIN | files | requires |  accepts  |  expands  |  null  |
   605	|         | avail |  set  |  access  | backslash | backslash | ARGV[] |
   606	|         |-------|-------|----------|-----------|-----------|--------|
   607	|      a) |   y   |  all  |     n    |     n     |     y     |   n    |
   608	|      c) |   n   |  sub  |     n    |     n     |     y     |   n    |
   609	|      d) |   y   |  all  |     n    |     n     |     n     |   y    |
   610	|      f) |   y   |  all  |     y    |     n     |     n     |   n    |
   611	|      g) |   y   |  all  |     n    |     y     |    n/a    |   n    |
   612	|         |-------|-------|----------|-----------|-----------|--------|
   613	|   
   614	|      where the columns mean:
   615	|   
   616	|      BEGIN avail = y: variable IS available in the BEGIN section
   617	|      BEGIN avail = n: variable is NOT available in the BEGIN section
   618	|   
   619	|      files set = all: variable is set for ALL files regardless of
   620	|                   command-line order.
   621	|      files set = sub: variable is ONLY set for those files subsequent
   622	|                   to the definition of the variable on the command line
   623	|   
   624	|      requires access = y: variable DOES need to be exported or set on
   625	|                   the command line
   626	|      requires access = n: shell variable does NOT need to be exported
   627	|                   or set on the command line
   628	|   
   629	|      accepts backslash = y: variable CAN contain a backslash without
   630	|                   causing awk to fail with a syntax error
   631	|      accepts backslash = n: variable can NOT contain a backslash without
   632	|                   causing awk to fail with a syntax error
   633	|   
   634	|      expands backslash = y: if the variable contains a backslash, it IS
   635	|                   expanded before execution begins
   636	|      expands backslash = n: if the variable contains a backslash, it is
   637	|                   NOT expanded before execution begins
   638	|   
   639	|      null ARGV[] = y: you DO end up with a null entry in the ARGV[]
   640	|           array
   641	|      null ARGV[] = n: you do NOT end up with a null entry in the ARGV[]
   642	|           array
   643	|   
   644	|      For most applications, form "a" and "d" provide the most intuitive
   645	|      functionality. The only functional differences between the 2 are:
   646	|   
   647	|      1) Whether or not backslashes get expanded on variable assignment.
   648	|      2) Whether or not ARGV[] ends up containing a null string.
   649	|   
   650	|      so which one you choose to use depends on your requirements for
   651	|      these 2 situations.
   652	|   
   653	|   ========================================================================
   654	|   
   655	|   14. How does awk deal with multiple files?
   656	|   
   657	|     Warning: some of these techniques will require 
   658	|     non-ancient versions of awk.
   659	|   
   660	|     14.1 How can awk test for the existence of a file?
   661	|   
   662	|       the most portable way is to simply try and read from the file.
   663	|   
   664	|           function exists(file,        dummy, ret)
   665	|           {
   666	|                   ret=0;
   667	|                   if ( (getline dummy < file) >=0 )
   668	|                   {
   669	|                           # file exists (possibly empty) and can be read
   670	|                           ret = 1;
   671	|                           close(file);
   672	|                   }
   673	|                   return ret;
   674	|           }
   675	|   
   676	|   [ I've read reports that earlier versions of mawk would write to stderr
   677	|   as well as getline returning <0 -- is this still true? ]
   678	|   
   679	|           on Unix, you can probably use the `test' utility
   680	|   
   681	|           if (system("test -r " file) == 0)
   682	|               # file is readable
   683	|           else
   684	|               # file is not readable
   685	|   
   686	|     14.2 How can I get awk to read multiple files?
   687	|   
   688	|       it's automatic (under Unix at least) -- use something like:
   689	|   
   690	|       awk '/^#include/ {print $2}' *.c *.h
   691	|   
   692	|     14.3 How can I tell from which file my input is coming?
   693	|   
   694	|       use the built-in variable FILENAME:
   695	|   
   696	|       awk '/^#include/ {print FILENAME,$2}' *.c *.h
   697	|   
   698	|     14.4 How can I get awk to open multiple files (selected at runtime)?
   699	|   
   700	|       use `getline', `close', and `print EXPR > FILENAME', like:
   701	|   
   702	|       # assumes input file has at least 1 line, output file writeable
   703	|       function double(infilename,outfilename,    aline)
   704	|       {
   705	|         while ( (getline aline < infilename) >0 )
   706	|           print(aline aline) > outfilename;
   707	|         close(infilename);
   708	|         close(outilename);
   709	|       }
   710	|   
   711	|     14.5 How can I treat the first file specially?
   712	|   
   713	|       use FILENAME, thusly:
   714	|   
   715	|       BEGIN { rulesfile="" }
   716	|       rulesfile == "" { rulesfile = FILENAME; }
   717	|       FILENAME == rulesfile { build_rule($0); }
   718	|       FILENAME != rulesfile { apply_rule($0); }
   719	|   
   720	|       Example:  
   721	|   
   722	|       Suppose you have a text-line "database" and you want to make some
   723	|       batch changes to it, by replacing some old lines with new lines.
   724	|    
   725	|       BEGIN { rulesfile="" }
   726	|       rulesfile == "" { rulesfile = FILENAME; }
   727	|       rulesfile == FILENAME { replace[$1] = $0; }
   728	|       rulesfile != FILENAME \
   729	|       { 
   730	|               if ($1 in replace) 
   731	|                       print replace[$1];
   732	|               else
   733	|                       print;
   734	|       }
   735	|   
   736	|       another way, using ARGV:
   737	|   
   738	|       (FILENAME == ARGV[1]) { replace[$1] = $0; next }
   739	|       ($1 in replace) { print replace[$1]; next }
   740	|       { print }
   741	|   
   742	|     14.6 How can I explicitly pass in a filename to treat specially?
   743	|   
   744	|       use `-v rulesfile=filename' like you would any other variable,
   745	|       and then use a `getline' loop (and `close') in your BEGIN
   746	|       statement.
   747	|   
   748	|       BEGIN \
   749	|       {
   750	|         if (rulesfile=="")
   751	|         {
   752	|           print "must use -v rulesfile=filename";
   753	|           exit(1);
   754	|         }
   755	|         while ( (getline < rulesfile) >0 )
   756	|           replace[$1]=$0;
   757	|         close(rulesfile);
   758	|       }
   759	|   
   760	|       {
   761	|         if ($1 in replace)
   762	|           print replace[$1];
   763	|         else
   764	|           print;
   765	|       }
   766	|   
   767	|   ========================================================================
   768	|   
   769	|   15. How many elements were created by split()?
   770	|   
   771	|      when I do a split on a field, e.g.,
   772	|    
   773	|           split($1,x,"string")
   774	|    
   775	|      how can i find out how many elements x has (I mean other than
   776	|      testing for null string or doing a `for (n in x)' test)?
   777	|   
   778	|   split() is a function; use its return value:
   779	|   
   780	|           n = split($1, x, "string")
   781	|   
   782	|   ========================================================================
   783	|   
   784	|   16. How can I split a string into characters?
   785	|   
   786	|   In portable POSIX awk, the only way to do this is to use substr to pull
   787	|   out each character, one by one.  This is painful.  However, gawk, mawk,
   788	|   and the newest version of the Bell Labs awk all allow you to set
   789	|   FS = "" and use "" as the third argument of split.
   790	|   
   791	|   So, split("chars",anarray,"") results in the array anarray containing
   792	|   5 elements -- "c", "h", "a", "r", "s".
   793	|   
   794	|   If you don't have any ^As in your string, you could try:
   795	|   
   796	|           string=$0;
   797	|           gsub(".", "&\001", string)
   798	|           n=split(string, anarray, "\001")
   799	|           for (i=1;i<=n;i++)
   800	|               print "character " i "is '" anarray[i] "'";
   801	|   
   802	|   ========================================================================
   803	|   
   804	|   17. How do I have dynamic-width printf strings, like C?
   805	|   
   806	|     With modern awks, you can just do it like you would in C (though the
   807	|     justification is less clear; C doesn't have the trivial in-line string
   808	|     concatenation that awk does), like so:
   809	|   
   810	|           maxlen=0
   811	|   
   812	|           for (i in arr)
   813	|             if (maxlen<length(arr[i]))
   814	|               maxlen=length(arr[i])
   815	|   
   816	|           for (i in arr)
   817	|             printf("%-*s %s\n",maxlen,arr[i],i)
   818	|   
   819	|     With old awks, just do it like you would do if you didn't know about %*
   820	|     (this would be much more painful to do in C), like so:
   821	|   
   822	|           maxlen=0
   823	|   
   824	|           for (i in arr)
   825	|             if (maxlen<length(arr[i]))
   826	|               maxlen=length(arr[i])
   827	|   
   828	|           printfstring="%-" maxlen "s %s\n";
   829	|           for (i in arr)
   830	|             printf(printfstring,arr[i],i)
   831	|   
   832	|   ========================================================================
   833	|   
   834	|   18. Why doesn't "\\$" behave like /\\$/ ?  Why don't parentheses match?
   835	|   
   836	|     Because "\\$" is a string and /\\$/ is not; in strings, some of the
   837	|     escape characters get eaten up (like \" to escape a double-quote within
   838	|     the string).
   839	|     
   840	|     /\\$/ => regular expression:  literal backslash at end-of-expression
   841	|     
   842	|     "\\$" => string: \$ => regular expression:  literal dollar sign
   843	|     
   844	|     to get behavior like the first case in a string, use "\\\\$" .
   845	|     
   846	|     there are other, less obvious characters which need the same attention;
   847	|     under-quoting or over-quoting should be avoided:
   848	|     
   849	|     parentheses are special for alternation:
   850	|     
   851	|     /\(test\)/ => 6 characters `(test)'
   852	|     "\(test\)" => /(test)/ => 4 characters `test' (with unused grouping)
   853	|     
   854	|     an example of trying to match some diagonal compass directions:
   855	|     
   856	|     /(N|S)(E|W)/ => `NE' or `NW' or `SE' or `SW' (correct)
   857	|     "(N|S)(E|W)" => /(N|S)(E|W)/ (correct)
   858	|     "\(N|S\)\(E|W\)" => /(N|S)(E|W)/ (correct) (NOTE:  all \ had no effect)
   859	|     "\(N\|S\)\(E\|W\)" => /(N|S)(E|W)/ (correct) (NOTE:  all \ had no effect)
   860	|     
   861	|     expressions that look similar but behave totally differently:
   862	|     
   863	|     /\(N|S\)\(E|W\)/ => `(N' or `S)(E' or `W)'
   864	|     /\(N\|S\)\(E\|W\)/ => `(N|S)(E|W)' only
   865	|     
   866	|     There is also confusion regarding different forms of special characters;
   867	|     POSIX requires that `\052' be treated as any other `*', even though it
   868	|     is written with 4 bytes instead of 1.  In compatibility mode, gawk will
   869	|     treat it as though it were escaped , namely `\*'.
   870	|     
   871	|   ========================================================================
   872	|   
   873	|   19. What is awk's exit code?
   874	|   
   875	|     Normally, the `exit' command exits with a value of zero.
   876	|     
   877	|     You can supply an optional numeric value to the `exit' command to
   878	|     make it exit with a value:
   879	|     
   880	|         if (whatever)
   881	|             exit 12;
   882	|     
   883	|     If you have an END block, control first transfers there.  Within
   884	|     the END block, an `exit' command exits immediately; if you had
   885	|     previously supplied a value, that value is used.  But, if you
   886	|     give a new value to `exit' within the END block, the new value is
   887	|     used.  This is documented in the GNU Awk User's Guide (gawk.texi).
   888	|     
   889	|     If you have an END block you want to be able to skip sometimes,
   890	|     you may have to do something like this:
   891	|     
   892	|     BEGIN \
   893	|     {
   894	|       exitcode=0;
   895	|       ...
   896	|     }
   897	|     
   898	|     # normal rules processing...
   899	|     {
   900	|       ...
   901	|       if (fatal)
   902	|       {
   903	|         exitcode=12;
   904	|         exit(exitcode);
   905	|       }
   906	|       ...
   907	|     }
   908	|     
   909	|     END {
   910	|       if (exitcode!=0)
   911	|         exit(exitcode);
   912	|       ...
   913	|     }
   914	|     
   915	|   ========================================================================
   916	|   
   917	|   20. How can I get awk to be case-insensitive?
   918	|   
   919	|     20.1. use tolower()
   920	|       - portable
   921	|       - must be explicitly used for each comparison
   922	|   
   923	|       instead of:
   924	|         if (avar=="a" || avar=="A") { ... }
   925	|       use:
   926	|         if (tolower(avar)=="a") { ... }
   927	|   
   928	|       or at the beginning of your code, add a line like
   929	|         { for (i=0;i<=NF;i++) $i=tolower($i) }
   930	|         { $0=tolower($0); }   # modern awks will rebuild $1..$NF also
   931	|   
   932	|     20.2. use IGNORECASE=1;
   933	|       - gawk only
   934	|       - used for all comparisons, regex comparisons, index() function
   935	|       - not used for array indexing
   936	|   
   937	|   ========================================================================
   938	|   
   939	|   21. How can I force a numeric/non-numeric comparison?
   940	|     
   941	|     These are the canonical, work-in-all-versions snippets.  there are
   942	|     many others, most longer, some shorter (but possibly less portable).
   943	|     
   944	|     To compare two variables as numbers ONLY, use
   945	|       if (0+var1 == 0+var2)
   946	|     
   947	|     To compare two variables as non-numeric strings ONLY, use
   948	|       if ("" var1 == "" var2)
   949	|     
   950	|   ========================================================================
   951	|   
   952	|   22. Why does { FS=":"; print $1 } not split the first record?
   953	|     
   954	|     Basically, you should set FS before it may be called upon to split $0
   955	|     into fields.  Once awk encounters a `{', it is probably too late.
   956	|     
   957	|     Some awk implementations set the fields at the beginning of the
   958	|     block, and don't re-parse just because you changed FS.  To get
   959	|     the desired behavior, you must set FS _before_ reading in a line.
   960	|     
   961	|     e.g.,
   962	|       BEGIN { FS=":" }
   963	|       { print $1 }
   964	|     
   965	|     e.g.,
   966	|       awk -F: '{ print $1 }'
   967	|     
   968	|     If you run code like this
   969	|       { FS=":"; print $1 }
   970	|     
   971	|     On this data:
   972	|       first:second:third but not last:fourth
   973	|       First:Second:Third But Not Last:Fourth
   974	|       FIRST:SECOND:THIRD BUT NOT LAST:FOURTH
   975	|     
   976	|     You may get either
   977	|       this:       or this:
   978	|       ----        -------
   979	|       first       first:second:third
   980	|       First       First
   981	|       FIRST       FIRST
   982	|     
   983	|     Perhaps more surprisingly, code like
   984	|       { FS=":"; }
   985	|       { print $1; }
   986	|     
   987	|     will also behave in the same way.
   988	|     
   989	|   ========================================================================
   990	|   
   991	|   23. Did ^ and $ and . change in gawk?
   992	|     
   993	|     Yes.  early versions cared about \n (newlines) and treated them
   994	|     specially.  version 3.* and later are more POSIX-compliant here.
   995	|     
   996	|   ========================================================================
   997	|   
   998	|   24. Why doesn't awk 'begin {...}' work?
   999	|     
  1000	|     It needs to be `BEGIN' (i.e., it's case-sensitive).
  1001	|     
  1002	|   ========================================================================
  1003	|   
  1004	|   25. Why does awk 'BEGIN { print 6 " " -22 }' lose the space?
  1005	|     
  1006	|     You'd expect `6 -22', but you get `6-22'.  It's because the `" " -22'
  1007	|     is grouped first, as a subtraction instead of a concatenation, resulting
  1008	|     in the numeric value `-22'; then it is concatenated with `6', giving the
  1009	|     string `6-22'.  Gentle application of parentheses will avoid this.
  1010	|     
  1011	|   ========================================================================
  1012	|   
  1013	|   26. How do I take advantage of gawk's networking support?
  1014	|     
  1015	|     (Contribution from Michael Sanders: see http://awk.info/?tools/server).
  1016	|     
  1017	|     This code creates an html menu of local applications which you can
  1018	|     season to taste. The usage requires two steps...
  1019	|     
  1020	|         1) run: 'gawk -f server.awk'
  1021	|         2) open browser at: http://localhost:8080
  1022	|         
  1023	|     This code is based on the examples located at the TCP/IP Internetworking
  1024	|     With `gawk' manual and is licensed under GPL 3.0. For updates to
  1025	|     this code, see http://topcat.hypermart.net/index.html.
  1026	|     
  1027	|     BEGIN {
  1028	|         x        = 1                        # script exits if x < 1
  1029	|         port     = 8080                     # port number
  1030	|         host     = "/inet/tcp/" port "/0/0" # host string
  1031	|         url      = "http://localhost:" port # server url
  1032	|         RS = ORS = "\r\n"                   # header line terminators
  1033	|         doc      = Setup()                  # html document
  1034	|         while (x) {
  1035	|           if ($1 == "GET") RunApp(substr($2, 2))
  1036	|           if (! x) break
  1037	|           Message(doc)
  1038	|           host |& getline # wait for new client request
  1039	|         }
  1040	|         Message(Bye())    # server terminated...
  1041	|     }
  1042	|   
  1043	|     #Server Message
  1044	|     function Message(txt) {
  1045	|        status = 200                       # 200 == OK
  1046	|        reason = "OK"                      # server response
  1047	|        len    = length(txt) + length(ORS) # length of document
  1048	|        print "HTTP/1.0", status, reason |& host
  1049	|        print "Connection: Close"        |& host
  1050	|        print "Pragma: no-cache"         |& host
  1051	|        print "Content-length:", len     |& host
  1052	|        print ORS txt                    |& host
  1053	|        close(host)
  1054	|     }
  1055	|   
  1056	|     #HTML Menu
  1057	|     function Setup() {
  1058	|        tmp = "<html>\
  1059	|        <head><title>Simple gawk server</title></head>\
  1060	|        <body>\
  1061	|        <p><a href=" url "/xterm>xterm</a>\
  1062	|        <p><a href=" url "/xcalc>xcalc</a>\
  1063	|        <p><a href=" url "/xload>xload</a>\
  1064	|        <p><a href=" url "/exit>terminate script</a>\
  1065	|        </body>\
  1066	|        </html>"
  1067	|        return tmp
  1068	|     }
  1069	|   
  1070	|     #Saying Good-bye
  1071	|     function Bye() {
  1072	|        tmp = "<html>\
  1073	|        <head><title>Simple gawk server</title></head>\
  1074	|        <body><p>Script Terminated...</body>\
  1075	|        </html>"
  1076	|        return tmp
  1077	|     }
  1078	|   
  1079	|     #Running Applications
  1080	|     function RunApp(app) {
  1081	|        if (app == "exit")       {x = 0}
  1082	|        else if (app == "xterm") {system("xterm&")}
  1083	|        else if (app == "xcalc") {system("xcalc&")}
  1084	|        else if (app == "xload") {system("xload&")}
  1085	|     }
  1086	|   
  1087	|   ========================================================================
  1088	|   
  1089	|   98. Miscellaneous
  1090	|   
  1091	|   ========================================================================
  1092	|   
  1093	|   99. Credits
  1094	|   
  1095	|     I most of the information in this FAQ has been be supplied by people
  1096	|     other than myself -- it just works better that way.  The newsgroup
  1097	|     readers have a LOT more awk experience than I ever will (unless I
  1098	|     multiply myself by a few thousand, which is not legal with today's
  1099	|     tax laws).
  1100	|     
  1101	|     The following people have contributed to the well-being of the FAQ: 
  1102	|     
  1103	|     New testament (from 2010):
  1104	|       tim [at] menzies.us (Tim Menzies) <== maintainer
  1105	|       
  1106	|       g_r_a_n_t_ [at] bugsplatter.id.au
  1107	|       mike [at] topcat.hypermart.net (Michael Sanders)
  1108	|   	mortonspam [at] gmail.com (Ed Morton)
  1109	|   
  1110	|     Old testament (up until 2002):
  1111	|       awkfaq at locutus.ofB.ORG (Russell Schulz) <== maintainer
  1112	|     
  1113	|       Alex.Schoenmakers [at] lhs.be
  1114	|       David.Billinghurst [at] riotinto.com (David Billinghurst)
  1115	|       Ferran.Jorba [at] uab.es (Ferran Jorba)
  1116	|       Juergen.Kahrs [at] t-online.de
  1117	|       Kalle.Tuulos [at] nmp.nokia.com (Kalle Tuulos)
  1118	|       SimonN [at] draeger.com (Nicole Simon)
  1119	|       afu [at] wta.att.ne.jp
  1120	|       allen [at] gateway.grumman.com (John L. Allen)
  1121	|       amnonc [at] mercury.co.il (Amnon Cohen)
  1122	|       andrew_sumner [at] bigfoot.com (Andrew Sumner)
  1123	|       arnold [at] skeeve.com (Arnold D. Robbins)
  1124	|       art [at] pove.com (Art Povelones)
  1125	|       bmarcum [at] iglou.com (Bill Marcum)
  1126	|       boffi [at] rachele.stru.polimi.it (giacomo boffi)
  1127	|       bps03z [at] email.mot.com (Peter Saffrey)
  1128	|       brennan [at] whidbey.com (Michael D. Brennan)
  1129	|       churchyh [at] ccwf.cc.utexas.edu (Henry Churchyard)
  1130	|       db21 [at] ih4ess.ih.lucent.com (David Beyerl)
  1131	|       dmckeon [at] swcp.com (Denis McKeon)
  1132	|       dmeier.esperanto [at] gmx.de (Detlef Meier)
  1133	|       dzubera [at] CS.ColoState.EDU (Zube)
  1134	|       edgar.j.ramirez [at] lmco.com (Edgar J. Ramirez)
  1135	|       eia018 [at] comp.lancs.ac.uk (Dr Andrew Wilson)
  1136	|       epement [at] ripco.com (Eric Pement)
  1137	|       gavin [at] wraith.u-net.com (Gavin Wraith)
  1138	|       hankedr [at] mail.auburn.edu (Darrel Hankerson)
  1139	|       hastinga [at] tarim.dialogic.com (Austin Hastings)
  1140	|       heiner.steven [at] nexgo.de (Heiner Steven)
  1141	|       hstein [at] airmail.net (Harry Stein)
  1142	|       j-korsv [at] online.no (Jon-Egil Korsvold)
  1143	|       jari.aalto [at] ntc.nokia.com (Jari Aalto)
  1144	|       jblaine [at] shore.net (Jeff Blaine)
  1145	|       jerabek [at] rm6208.gud.siemens.co.at (Martin Jerabek)
  1146	|       jesusmc [at] scripps.edu (Jesus M. Castagnetto)
  1147	|       jidanni [at] kimo.com.tw (Dan Jacobson)
  1148	|       jlaiho [at] ichaos.nullnet.fi (Juha Laiho)
  1149	|       jland [at] worldnet.att.net (Jim Land)
  1150	|       jmccann [at] WOLFENET.com (James McCann)
  1151	|       joe [at] plaguesplace.dyndns.org
  1152	|       johnd [at] mozart.inet.co.th (John DeHaven)
  1153	|       kahrs [at] iSenseIt.de (Juergen Kahrs)
  1154	|       konrad [at] netcom.com (Konrad Hambrick)
  1155	|       lehalle [at] earthling.net (Charles-Albert Lehalle)
  1156	|       lothar [at] u-aizu.ac.jp (Lothar M. Schmitt)
  1157	|       mark [at] ispc001.demon.co.uk (Mark Katz)
  1158	|       markus [at] biewer.com (Markus B. Biewer)
  1159	|       monty [at] primenet.com (Jim Monty)
  1160	|       morrisl [at] scn.org (Larry D. Morris)
  1161	|       neel [at] gnu.org
  1162	|       neil_mahoney [at] il.us.swissbank.com (Neil Mahoney)
  1163	|       neitzel [at] gaertner.de (Martin Neitzel)
  1164	|       peter.tillier [at] btinternet.com (Peter S Tillier)
  1165	|       pez68 [at] netscape.net (Peter Stromberg)
  1166	|       phil [at] bolthole.com (Philip Brown)
  1167	|       pholzleitner [at] unido.org (Peter HOLZLEITNER)
  1168	|       pierre [at] mail.asianet.it (Gianni Rondinini)
  1169	|       pjf [at] osiris.cs.uoguelph.ca (Peter Jaspers-Fayer)
  1170	|       pjfarley [at] banet.net (Peter J. Farley III)
  1171	|       ptjm [at] interlog.com (Patrick TJ McPhee)
  1172	|       rms [at] friko.onet.pl (Rafal Sulejman)
  1173	|       robin.moffatt [at] ntlworld.com (Robin Moffatt)
  1174	|       rwab1 [at] cl.cam.ac.uk (Ralph Becket)
  1175	|       saguyami [at] post.tau.ac.il (Shay)
  1176	|       thobe [at] lafn.org (Glenn Thobe) 
  1177	|       thull [at] ocston.org (Tom Hull)
  1178	|       tim [at] consultix-inc.com (Tim Maher/CONSULTIX)
  1179	|       vincent [at] delau.nl (Vincent de Lau)
  1180	|       vjpnreddy [at] hotmail.com (Jaya Reddy)
  1181	|       walkerj [at] compuserve.com (James G. Walker)
  1182	|       walter [at] wbriscoe.demon.co.uk (Walter Briscoe)
  1183	|       yuli.barcohen [at] telrad.co.il (Yuli Barcohen)
  1184	|   
  1185	|     Thanks.
  1186	|   
  1187	|   ========================================================================
  1188	|   
  1189	|   thus endeth the awk FAQ.
